pragma solidity 0.4.11;
import "Markets/AbstractMarket.sol";
import "Tokens/AbstractToken.sol";
import "Events/AbstractEvent.sol";
import "MarketMakers/AbstractMarketMaker.sol";


/// @title Market factory contract - Allows to create market contracts
/// @author Stefan George - <stefan@gnosis.pm>
contract DefaultMarket is Market {

    /*
     *  Constants
     */
    uint public constant FEE_RANGE = 1000000; // 100%

    /*
     *  Storage
     */
    address public creator;
    uint public createdAtBlock;
    Event public eventContract;
    MarketMaker public marketMaker;
    uint public fee;
    uint public funding;

    /*
     *  Modifiers
     */
    modifier isCreator () {
        if (msg.sender != creator)
            revert();
        _;
    }

    /*
     *  Public functions
     */
    /// @dev Constructor validates and sets market properties and invests initial funding
    /// @param _creator Market creator
    /// @param _eventContract Event contract
    /// @param _marketMaker Market maker contract
    /// @param _fee Market fee
    function DefaultMarket(address _creator, Event _eventContract, MarketMaker _marketMaker, uint _fee)
        public
    {
        if (address(_eventContract) == 0 || address(_marketMaker) == 0 || _fee >= FEE_RANGE)
            // Values are null
            revert();
        creator = _creator;
        createdAtBlock = block.number;
        eventContract = _eventContract;
        fee = _fee;
        marketMaker = _marketMaker;
    }

    /// @dev Allows to fund the market with collateral tokens converting them into outcome tokens
    /// @param _funding Funding amount
    function fund(uint _funding)
        public
        isCreator
    {
        if (   !eventContract.collateralToken().transferFrom(msg.sender, this, _funding)
            || !eventContract.collateralToken().approve(eventContract, _funding))
            // Sender doesn't have enough tokens to do the funding or token approval failed
            revert();
        eventContract.buyAllOutcomes(_funding);
        funding += _funding;
    }

    /// @dev Allows market creator to close the markets by transferring all remaining outcome tokens to the creator
    function close()
        public
        isCreator
    {
        uint8 outcomeCount = eventContract.getOutcomeCount();
        for (uint8 i=0; i<outcomeCount; i++)
            eventContract.outcomeTokens(i).transfer(creator, eventContract.outcomeTokens(i).balanceOf(this));
    }

    /// @dev Allows market creator to withdraw fees generated by trades
    /// @return Returns fee amount
    function withdrawFees()
        public
        isCreator
        returns (uint fees)
    {
        fees = eventContract.collateralToken().balanceOf(this);
        if (!eventContract.collateralToken().transfer(creator, fees))
            revert();
    }

    /// @dev Allows to buy outcome tokens from market maker
    /// @param outcomeTokenIndex Index of the outcome token to buy
    /// @param outcomeTokenCount Amount of outcome tokens to buy
    /// @param maxCosts The maximum costs in collateral tokens to pay for outcome tokens
    /// @return Returns costs in collateral tokens
    function buy(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint maxCosts)
        public
        returns (uint costs)
    {
        // Calculate costs to buy outcome tokens
        uint outcomeTokenCosts = marketMaker.calcCosts(this, outcomeTokenIndex, outcomeTokenCount);
        // Calculate fee charged by market
        uint fee = calcMarketFee(outcomeTokenCosts);
        costs = outcomeTokenCosts + fee;
        // Check costs don't exceed max costs
        if (costs == 0 || costs > maxCosts)
            // Amount of token is too small or tokens are more expensive
            revert();
        // Transfer tokens to markets contract and buy all outcomes
        if (   !eventContract.collateralToken().transferFrom(msg.sender, this, costs)
            || !eventContract.collateralToken().approve(eventContract, outcomeTokenCosts))
            revert();
        // Buy all outcomes
        eventContract.buyAllOutcomes(outcomeTokenCosts);
        // Transfer outcome tokens to buyer
        eventContract.outcomeTokens(outcomeTokenIndex).transfer(msg.sender, outcomeTokenCount);
    }

    /// @dev Allows to sell outcome tokens to market maker
    /// @param outcomeTokenIndex Index of the outcome token to sell
    /// @param outcomeTokenCount Amount of outcome tokens to sell
    /// @param minProfits The minimum profits in collateral tokens to earn for outcome tokens
    /// @return Returns profits in collateral tokens
    function sell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfits)
        public
        returns (uint profits)
    {
        // Calculate profits for selling outcome tokens
        uint outcomeTokenProfits = marketMaker.calcProfits(this, outcomeTokenIndex, outcomeTokenCount);
        // Calculate fee charged by market
        uint fee = calcMarketFee(outcomeTokenProfits);
        profits = outcomeTokenProfits - fee;
        // Check profits are not too low
        if (profits == 0 || profits < minProfits)
            // Amount of token is too small or profits are too low
            revert();
        // Transfer outcome tokens to markets contract to sell all outcomes
        eventContract.outcomeTokens(outcomeTokenIndex).transferFrom(msg.sender, this, outcomeTokenCount);
        // Sell all outcomes
        eventContract.sellAllOutcomes(outcomeTokenProfits);
        // Transfer profits to seller
        if (!eventContract.collateralToken().transfer(msg.sender, profits))
            revert();
    }

    /// @dev Allows to short sell outcome tokens to market maker
    /// @param outcomeTokenIndex Index of the outcome token to short sell
    /// @param outcomeTokenCount Amount of outcome tokens to short sell
    /// @param minProfits The minimum profits in collateral tokens to earn for short sold outcome tokens
    /// @return Returns costs in collateral tokens
    function shortSell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfits)
        public
        returns (uint costs)
    {
        // Buy all outcomes
        if (   !eventContract.collateralToken().transferFrom(msg.sender, this, outcomeTokenCount)
            || !eventContract.collateralToken().approve(eventContract, outcomeTokenCount))
            // Sender did not approve enough tokens
            revert();
        eventContract.buyAllOutcomes(outcomeTokenCount);
        // Short sell selected outcome
        eventContract.outcomeTokens(outcomeTokenIndex).approve(this, outcomeTokenCount);
        uint profits = this.sell(outcomeTokenIndex, outcomeTokenCount, minProfits);
        costs = outcomeTokenCount - profits;
        // Transfer outcome tokens to buyer
        uint8 outcomeCount = eventContract.getOutcomeCount();
        for (uint8 i =0; i<outcomeCount; i++)
            if (i != outcomeTokenIndex)
                eventContract.outcomeTokens(i).transfer(msg.sender, outcomeTokenCount);
        // Send change back to buyer
        if (!eventContract.collateralToken().transfer(msg.sender, profits))
            // Couldn't send user change back
            revert();
    }

    /// @dev Calculates fee to be paid to market maker
    /// @param outcomeTokenCosts Costs for buying outcome tokens
    /// @return Returns fee for trade
    function calcMarketFee(uint outcomeTokenCosts)
        public
        constant
        returns (uint)
    {
        return outcomeTokenCosts * fee / FEE_RANGE;
    }
}
